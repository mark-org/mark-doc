P122
# 集群并处理失败
* 要让rabbitMq变成高可用性有两种方法。
>> * 其中一种是设置rabbit集群 ，这样你可以从任何一台rabbit故障中得以幸免，并且应用程序能够持续运作而不会停顿。
>> * 另一种方法是扩大程序的规模以提升性能。

## rabbitMq集群
最优秀的功能之一就是其内建集群。
* 两个目标：允许消费者和生产者在rabbit节点崩溃的情况下继续运行，以及通过添加更多的节点来线性扩展消息通信吞吐量。
* rabbitMq集群不能保证消息的万无一失。

P122
* 如果rabbit集群正疲于应对庞大消息通信量的话，那么添加更多的节点会线性地增加更多性能。
* rabbitMq集群不能消息的万无一失。
* rabbitMq默认不会将队列的内容复制到整个集群上。如不特别的配置，这些消息仅存在于队列所属的那个节点上。

### rabbitMq会始终记录以下四种类型的内部元数据：
* 队列元数据
* 交换器元数据
* 绑定元数据
* vhost元数据
*** 在单一节点内，rabbitmq会将所有这些信息存储在内存中，同时将那些标记为可持久化的队列和交换器（以及它们的绑定）存储到硬盘上。***
* 当引入集群时，rabbitmq需要追踪新的元数据类型

## 集群中的队列
* 在将两个节点组成集群的那一刻，事情发生了巨大的变化：不是每一个节点都有所有队列的完全拷贝。
* 所有其他所有者节点只知道队列的元数据和指向该队列存在的那个节点的指针。
* 因此当集群节点崩溃时，该节点的队列和关联的绑定就都消失了。


* 想要该指定队列重回集群的唯一方法是恢复故障节点。
### 为什么默认情况下rabbitmq不将队列内容和状态复制到所有的节点上呢?
1.存储空间
2.性能

### 分布交换器
* 交换器只不对是一张查询表，而非实际上的消息路由器，因此将交换器在整个集群中进行复制会更简单。
* 事务模式和发送方确认模式都能确保应用程序一直发布而不丢失一条消息。

### 是内存节点还是节点（rabbitMq节点）
* 要么是内存节点RAM node(元数据定义都仅存储在内存中)
* 要么是磁盘节点disk node(元数据存储在磁盘中)
* 单节点系统只允许磁盘类型的节点，否则，每次你重启rabbitmq之后，所有关于系统的配置信息都会丢失
* 在集群中，你可以选择配置部分节点为内存节点。因为它使得像队列和交换器声明之类的操作更加快速。

* 当在集群中声明队列、交换器或者绑定的时候，这些操作会直到所有集群节点都成功提交元数据变更后才返回。

* rabbitmq只要求在集群中至少有一个节点。所有其他节点可以是内存节点。记住，当节点加入或者离开集群时，
	它们必须要将该变更通知至少一个磁盘节点。

P128	
### 在笔记本电脑上设置集群
rabbitmqctl stop
* 在每次调用rabbitmq-server命令前，我们通过设置RABBITMQ_NODENAME和RABBITMQ_NODE_PORT环境变量来明确
  指定唯一的节点名称和端口号
* 启动后，但是每个节点仍然是独立节点，拥有自己的元数据，并且不知道其它节点的存在。
  集群中的第一个节点将初始元数据带入集群中，并且无须被告知加入。
* rabbbitmqctl工具会帮你和每个节点通信并完成以上的任务。


* (停止第二个)rabbitmqctl -n rabbit _1@Phantome stor_app
* 清空 rabbitmqctl -n rabbit_1@Phantome reset
* 加入 rabbitmqctl -n rabbit_1@Phantome cluster rabbit@Phantome rabbit_1@Phantome

### 镜像队列
镜像节点在集群中的其他节点上拥有从队列(slave)拷贝。 一旦队列主节点不可用，
最老的从队列将被选择为新的主队列。
* 声明镜像队列就像声明普通队列一样;你传入一个额外的x-ha-policy参数到queue.declare调用中。

* 在非镜像队列的rabbit集群中，信道负责将消息路由到合适的队列。当加入镜像队列后，信道仍然做着同样的事情.
  它也要将消息投递到镜像队列的从拷贝。
* 在某种程度上，你可以将镜像队列视为拥有一个隐藏的fanout交换器，它指示着信道将消息分发到队列的从拷贝上。

P143
























