

# rabbitMq
http://134.175.231.104:15672 	test/test


# 概念
* producer的消息包含两个部分：有效载荷(payload)和标签(label)
* 信道(channel),在一条TCP连接上创建信道.不使用每秒建立成百上千条连接
* TCP连接就像电缆，而AMQP信道就像一条条独立的光纤束
### 队列
AMQP消息路由：交换器、队列和绑定。
* 消费者通过以下两种方式从特定的队列中接收消息:
1. basic.consume命令订阅。将信道置为接收模式，直到取消对队列的订阅为止。(持续订阅)
2. 只想从队列获得单条消息。basic.get命令实现。如果想获取更多，再次发送basic.get命令实现。如果想获取更多，再次发送basic.get。
不应该把basic.get放在一个循环里来替代basic.consume。因为这样做会影响Rabbit的性能。

* 当有多个消费者时，队列收到的消息将以循环(round-robin)的方式发送给消息者。 
  每条消息只会发送给一个订阅的消费者。
* 消费者接收到的每一条消息都必须进行确认。消费者必须通过basic.ack命令显式地向RabbitMQ发送一个确认，
  或者在订阅到队列的时候就将auto_ack参数设置为true。当设置了auto_act时，一旦消费者接收消息，RabbitMQ
  会自动视其确认了消息。

### 重复消费问题
	如果消费者收到一条消息，然后确认之前从Rabbit断开连接(或者从队列上取消订阅)，RabbitMQ会认为这条消息没有分发，
	然后重新分发给下一个订阅的消费者。
* 你可以好好利用这一点。如果处理消息内容非常耗时，则你的应用程序可以延迟确认该消息，直到消息处理完成。
  这样可以防止Rabbit持续不断的消息涌向你的应用而导致过载。

### 收到消息后，想明确拒绝而不是确认收到该消息
* 只要消息尚未确认，有以下两个选择:
1. 把消费者从rabbitMQ服务器断开连接。
2. 使用basic.reject, 参数requeue为true时，重新发送给下个订阅者。false则移除。也可以通过确认来忽略
* basic.reject并且requeue=false,将会进入dead letter（死信）队列，用来存放那些被拒绝而不重入队列的消息。
* 死信队列让你吃的饭这检测拒绝/未送达的消息来发现问题

* 消息者和生产者都能使用queue.declare来创建队列。如果消息者已经订阅，再无法再声明队列。
* 队列设置中另一些有用的参数:
>> * exclusive -- true:队列将变成私有的，此时只有你的应用程序才能够消费队列消息。
>> * auto-delete -- 当最后一个消息者取消订阅的时候，队列就会自动移除。
     如果你需要临时队列只为一个消费者服务的话，请结合使用auto-delete和exclusive。当消费者断开连接时，队列就被移除了。
	 
# 联合起来：交换器和绑定
* 根据确定的规则，rabbitMQ将会决定消息该投递到哪个队列。这些规则被作路由键(routing key)。
* 队列通过路由键绑定到交换器。
交换器四种类型：direct、fanout、toic和headers。
>> * direct交换器非常简单：如果路由键匹配的话，消息就被投递到对应的队列。
>> * 服务器必须实现direct类型交换器，包含一个空白字符串名称的默认交换器。
$channel->basic_publish($msg, '', 'queue-name');

* fanout交换器: 当你发送一条消息到fanout交换时，它会把消息投递给所有附加在此交换器上的队列。
* 举例：一个Web应用程序可能需要在用户上传新的图片时，用户相册必须清除缓存，
  同时用户应该得到些积分奖励。你可以将两个队列绑定到图片上传交换器上。一个用于清除缓存，另一个用于增加用户积分。
  从这个场景中你可以了解到，使用交换器、绑定和队列比直接向指定的队列发送消息要有优势。解耦
 
* topic交换器，允许你实现有趣的消息通信场景，它使得来自不同源头的消息能够到达同一个队列。
* 举例：日志系统，日志级别：error、info和warning. 应用程序模块:user-profile、image-gallery、msg-inbox等。
  你可以在队列绑定到交换器上的时候使用通配符。单个"."把路由键分为了几部分，“*”匹配特定位置的任意文本。
  为了实现匹配所有规则，你可以使用”#"字符：
 
 
# 多租户模式：虚拟主机和隔离
### vhost
* 每一个rabbitMQ服务器都能创建虚拟消息服务器，我们称之为虚拟主机vhost
* 每一个vhost本质是一个mini版本RabbitMQ服务器，拥有自己的队列、交换器和绑定...更重要的是，它拥有自己的权限机制。
* vhost是AMQP概念的基础，你必须在连接时进行指定。默认vhost: "/"，默认用户和密码guest/guest
* 在rabbit里创建一个用户时，用户通常会被指派给至少一个vhost, 并且只能访问被指派vhost内的队列、交换器和绑定。

* 当你在RabbitMQ集群上创建vhost时，整个集群上都会创建该vhost。


# 持久化和你的策略（丢消息问题）
* 重启rabbitMQ服务器后，那些队列和交换器就都消失了(随同里面的消息)。原因在于每个队列和交换器的durable属性。
  该属性默认情况为false，它决定了rabbitMQ是否需要在崩溃或者重启之后重新创建队列（或者交换器）。
* 队列和交换器当然必须被置成true，但光这样做还不够。
* 能从AMQP服务器崩溃中恢复的消息，我们称之为持久化消息。在消息发布前，通过把它的“投递模式”（delivery mode）
  选项设置2（AMQP客户端可能会使用人性化的常量来代替数值）来把消息标记成持久化。
  但是它还必须被发布到持久化的交换器中并到达持久化的队列中才行。
* 因此， 如果消息想要从Rabbit崩溃中恢复，那么消息必须：
>> * 把它的投递模式选项设置为2(持久)
>> * 发送到持久化的交换器
>> * 到达持久化的队列
* 持久化会极大地减少rabbitMQ服务器每秒可处理的消息总数。10倍以上。
* 虽然rabbitMq集群允许你和集群中的任何节点的任一队列进行通信，但是事实上那些队列
  均匀地分布在各个节点而没有冗余（在集群中任何一个队列都没有备份的拷贝）...导致消息丢失。
  
### AMQP事务(transaction)
* 不要把AMQP事务和大多数数据库的事务概念搞混了。在AMQP中，在把信道设置成事务模式后，
  你通过信道发送那些想要确认的消息，之后还有多个其它AMQP命令。
  事务填补了生产者发布消息以及rabbitMQ将它们提交到磁盘上这两者之间“最后1英里”的差距。不过，还有更好的方法来增补差距。
* 使用事务不但会降低大约2~10倍的消息吞吐量，而且会使生产者应用程序生产同步。而你使用消息通信就是想要避免同步。
* rabbitMq团队决定拿出更好的方案来保证消息投递：发送方确认模式。和事务相仿，你需要告诉rabbit将信息设置成confirm模式，


* 一旦信道进入confirm模式，所有在信道上发布的消息都会被指派一个唯一的ID号(从1开始)。一旦消息被投递给所有匹配的队列后，
  信道会发送一个发送方确认模式给生产者应用程序(包含消息的唯一的ID)。这使得生产者知晓消息已经安全到达目的队列了。
* 如果消息和队列是可持久化的，那么确认消息只会在队列将消息写入磁盘后才会发出。发送方确认模式的最大好处是它们是异步的。
  一旦发布了一条消息，生产者应用程序就可以在等待确认的同时继续发送下一条。当确认消息最终收到的时候，生产者应用的回调方法就
 会被触发来处理该确认消息。失败的话发nack(not acknowledged，未确认)

	 














